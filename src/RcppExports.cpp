// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/RQuantLib.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// asianOptionEngine
Rcpp::List asianOptionEngine(std::string averageType, std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double first, double length, size_t fixings);
RcppExport SEXP RQuantLib_asianOptionEngine(SEXP averageTypeSEXP, SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP firstSEXP, SEXP lengthSEXP, SEXP fixingsSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type averageType(averageTypeSEXP );
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP );
        Rcpp::traits::input_parameter< double >::type first(firstSEXP );
        Rcpp::traits::input_parameter< double >::type length(lengthSEXP );
        Rcpp::traits::input_parameter< size_t >::type fixings(fixingsSEXP );
        Rcpp::List __result = asianOptionEngine(averageType, type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, first, length, fixings);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// binaryOptionEngine
Rcpp::List binaryOptionEngine(std::string binType, std::string type, std::string excType, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double cashPayoff);
RcppExport SEXP RQuantLib_binaryOptionEngine(SEXP binTypeSEXP, SEXP typeSEXP, SEXP excTypeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP cashPayoffSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type binType(binTypeSEXP );
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< std::string >::type excType(excTypeSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP );
        Rcpp::traits::input_parameter< double >::type cashPayoff(cashPayoffSEXP );
        Rcpp::List __result = binaryOptionEngine(binType, type, excType, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, cashPayoff);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// binaryOptionImpliedVolatilityEngine
double binaryOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double cashPayoff);
RcppExport SEXP RQuantLib_binaryOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP cashPayoffSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< double >::type value(valueSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP );
        Rcpp::traits::input_parameter< double >::type cashPayoff(cashPayoffSEXP );
        double __result = binaryOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, cashPayoff);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// barrierOptionEngine
Rcpp::List barrierOptionEngine(std::string barrType, std::string type, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility, double barrier, double rebate);
RcppExport SEXP RQuantLib_barrierOptionEngine(SEXP barrTypeSEXP, SEXP typeSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP, SEXP barrierSEXP, SEXP rebateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type barrType(barrTypeSEXP );
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP );
        Rcpp::traits::input_parameter< double >::type barrier(barrierSEXP );
        Rcpp::traits::input_parameter< double >::type rebate(rebateSEXP );
        Rcpp::List __result = barrierOptionEngine(barrType, type, underlying, strike, dividendYield, riskFreeRate, maturity, volatility, barrier, rebate);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// bermudanSwaptionEngine
Rcpp::List bermudanSwaptionEngine(Rcpp::List rparam, Rcpp::List tslist, Rcpp::NumericVector swaptionMat, Rcpp::NumericVector swapLengths, Rcpp::NumericMatrix swaptionVols);
RcppExport SEXP RQuantLib_bermudanSwaptionEngine(SEXP rparamSEXP, SEXP tslistSEXP, SEXP swaptionMatSEXP, SEXP swapLengthsSEXP, SEXP swaptionVolsSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< Rcpp::List >::type rparam(rparamSEXP );
        Rcpp::traits::input_parameter< Rcpp::List >::type tslist(tslistSEXP );
        Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swaptionMat(swaptionMatSEXP );
        Rcpp::traits::input_parameter< Rcpp::NumericVector >::type swapLengths(swapLengthsSEXP );
        Rcpp::traits::input_parameter< Rcpp::NumericMatrix >::type swaptionVols(swaptionVolsSEXP );
        Rcpp::List __result = bermudanSwaptionEngine(rparam, tslist, swaptionMat, swapLengths, swaptionVols);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// setCalendarContext
bool setCalendarContext(std::string calendar, int fixingDays, QuantLib::Date settleDate);
RcppExport SEXP RQuantLib_setCalendarContext(SEXP calendarSEXP, SEXP fixingDaysSEXP, SEXP settleDateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< int >::type fixingDays(fixingDaysSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type settleDate(settleDateSEXP );
        bool __result = setCalendarContext(calendar, fixingDays, settleDate);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// isBusinessDay
std::vector<bool> isBusinessDay(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_isBusinessDay(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<bool> __result = isBusinessDay(calendar, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// isHoliday
std::vector<bool> isHoliday(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_isHoliday(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<bool> __result = isHoliday(calendar, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// isWeekend
std::vector<bool> isWeekend(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_isWeekend(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<bool> __result = isWeekend(calendar, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// isEndOfMonth
std::vector<bool> isEndOfMonth(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_isEndOfMonth(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<bool> __result = isEndOfMonth(calendar, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// getEndOfMonth
std::vector<QuantLib::Date> getEndOfMonth(std::string calendar, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_getEndOfMonth(SEXP calendarSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<QuantLib::Date> __result = getEndOfMonth(calendar, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// adjust
std::vector<QuantLib::Date> adjust(std::string calendar, std::vector<QuantLib::Date> dates, int bdc = 0);
RcppExport SEXP RQuantLib_adjust(SEXP calendarSEXP, SEXP datesSEXP, SEXP bdcSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        Rcpp::traits::input_parameter< int >::type bdc(bdcSEXP );
        std::vector<QuantLib::Date> __result = adjust(calendar, dates, bdc);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// advance1
std::vector<QuantLib::Date> advance1(std::string calendar, double amount, double unit, int bdcVal, double emr, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_advance1(SEXP calendarSEXP, SEXP amountSEXP, SEXP unitSEXP, SEXP bdcValSEXP, SEXP emrSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< double >::type amount(amountSEXP );
        Rcpp::traits::input_parameter< double >::type unit(unitSEXP );
        Rcpp::traits::input_parameter< int >::type bdcVal(bdcValSEXP );
        Rcpp::traits::input_parameter< double >::type emr(emrSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<QuantLib::Date> __result = advance1(calendar, amount, unit, bdcVal, emr, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// advance2
std::vector<QuantLib::Date> advance2(std::string calendar, double period, int bdcVal, double emr, std::vector<QuantLib::Date> dates);
RcppExport SEXP RQuantLib_advance2(SEXP calendarSEXP, SEXP periodSEXP, SEXP bdcValSEXP, SEXP emrSEXP, SEXP datesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< double >::type period(periodSEXP );
        Rcpp::traits::input_parameter< int >::type bdcVal(bdcValSEXP );
        Rcpp::traits::input_parameter< double >::type emr(emrSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type dates(datesSEXP );
        std::vector<QuantLib::Date> __result = advance2(calendar, period, bdcVal, emr, dates);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// businessDaysBetween
std::vector<double> businessDaysBetween(std::string calendar, std::vector<QuantLib::Date> from, std::vector<QuantLib::Date> to, bool includeFirst = true, bool includeLast = false);
RcppExport SEXP RQuantLib_businessDaysBetween(SEXP calendarSEXP, SEXP fromSEXP, SEXP toSEXP, SEXP includeFirstSEXP, SEXP includeLastSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type from(fromSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type to(toSEXP );
        Rcpp::traits::input_parameter< bool >::type includeFirst(includeFirstSEXP );
        Rcpp::traits::input_parameter< bool >::type includeLast(includeLastSEXP );
        std::vector<double> __result = businessDaysBetween(calendar, from, to, includeFirst, includeLast);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// getHolidayList
std::vector<QuantLib::Date> getHolidayList(std::string calendar, QuantLib::Date from, QuantLib::Date to, bool includeWeekends = false);
RcppExport SEXP RQuantLib_getHolidayList(SEXP calendarSEXP, SEXP fromSEXP, SEXP toSEXP, SEXP includeWeekendsSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< std::string >::type calendar(calendarSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type from(fromSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type to(toSEXP );
        Rcpp::traits::input_parameter< bool >::type includeWeekends(includeWeekendsSEXP );
        std::vector<QuantLib::Date> __result = getHolidayList(calendar, from, to, includeWeekends);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// advanceDate
QuantLib::Date advanceDate(QuantLib::Date issueDate, int days);
static SEXP RQuantLib_advanceDate_try(SEXP issueDateSEXP, SEXP daysSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< QuantLib::Date >::type issueDate(issueDateSEXP );
        Rcpp::traits::input_parameter< int >::type days(daysSEXP );
        QuantLib::Date __result = advanceDate(issueDate, days);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_advanceDate(SEXP issueDateSEXP, SEXP daysSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_advanceDate_try(issueDateSEXP, daysSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// dayCount
std::vector<double> dayCount(std::vector<QuantLib::Date> startDates, std::vector<QuantLib::Date> endDates, std::vector<double> dayCounters);
static SEXP RQuantLib_dayCount_try(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type startDates(startDatesSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type endDates(endDatesSEXP );
        Rcpp::traits::input_parameter< std::vector<double> >::type dayCounters(dayCountersSEXP );
        std::vector<double> __result = dayCount(startDates, endDates, dayCounters);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_dayCount(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_dayCount_try(startDatesSEXP, endDatesSEXP, dayCountersSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// yearFraction
std::vector<double> yearFraction(std::vector<QuantLib::Date> startDates, std::vector<QuantLib::Date> endDates, std::vector<double> dayCounters);
static SEXP RQuantLib_yearFraction_try(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type startDates(startDatesSEXP );
        Rcpp::traits::input_parameter< std::vector<QuantLib::Date> >::type endDates(endDatesSEXP );
        Rcpp::traits::input_parameter< std::vector<double> >::type dayCounters(dayCountersSEXP );
        std::vector<double> __result = yearFraction(startDates, endDates, dayCounters);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_yearFraction(SEXP startDatesSEXP, SEXP endDatesSEXP, SEXP dayCountersSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_yearFraction_try(startDatesSEXP, endDatesSEXP, dayCountersSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// setEvaluationDate
bool setEvaluationDate(QuantLib::Date evalDate);
static SEXP RQuantLib_setEvaluationDate_try(SEXP evalDateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP );
        bool __result = setEvaluationDate(evalDate);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_setEvaluationDate(SEXP evalDateSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_setEvaluationDate_try(evalDateSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// discountCurveEngine
Rcpp::List discountCurveEngine(Rcpp::List rparams, Rcpp::List tslist, Rcpp::NumericVector times);
RcppExport SEXP RQuantLib_discountCurveEngine(SEXP rparamsSEXP, SEXP tslistSEXP, SEXP timesSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< Rcpp::List >::type rparams(rparamsSEXP );
        Rcpp::traits::input_parameter< Rcpp::List >::type tslist(tslistSEXP );
        Rcpp::traits::input_parameter< Rcpp::NumericVector >::type times(timesSEXP );
        Rcpp::List __result = discountCurveEngine(rparams, tslist, times);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// calibrateHullWhiteUsingCapsEngine
Rcpp::List calibrateHullWhiteUsingCapsEngine(SEXP termStrcDateVec, SEXP termStrcZeroVec, SEXP capDataDF, SEXP iborDateVec, SEXP iborZeroVec, std::string iborType, QuantLib::Date evalDate);
RcppExport SEXP RQuantLib_calibrateHullWhiteUsingCapsEngine(SEXP termStrcDateVecSEXP, SEXP termStrcZeroVecSEXP, SEXP capDataDFSEXP, SEXP iborDateVecSEXP, SEXP iborZeroVecSEXP, SEXP iborTypeSEXP, SEXP evalDateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< SEXP >::type termStrcDateVec(termStrcDateVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type termStrcZeroVec(termStrcZeroVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type capDataDF(capDataDFSEXP );
        Rcpp::traits::input_parameter< SEXP >::type iborDateVec(iborDateVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type iborZeroVec(iborZeroVecSEXP );
        Rcpp::traits::input_parameter< std::string >::type iborType(iborTypeSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP );
        Rcpp::List __result = calibrateHullWhiteUsingCapsEngine(termStrcDateVec, termStrcZeroVec, capDataDF, iborDateVec, iborZeroVec, iborType, evalDate);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// calibrateHullWhiteUsingSwapsEngine
Rcpp::List calibrateHullWhiteUsingSwapsEngine(SEXP termStrcDateVec, SEXP termStrcZeroVec, SEXP swapDataDF, SEXP iborDateVec, SEXP iborZeroVec, std::string iborType, QuantLib::Date evalDate);
RcppExport SEXP RQuantLib_calibrateHullWhiteUsingSwapsEngine(SEXP termStrcDateVecSEXP, SEXP termStrcZeroVecSEXP, SEXP swapDataDFSEXP, SEXP iborDateVecSEXP, SEXP iborZeroVecSEXP, SEXP iborTypeSEXP, SEXP evalDateSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< SEXP >::type termStrcDateVec(termStrcDateVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type termStrcZeroVec(termStrcZeroVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type swapDataDF(swapDataDFSEXP );
        Rcpp::traits::input_parameter< SEXP >::type iborDateVec(iborDateVecSEXP );
        Rcpp::traits::input_parameter< SEXP >::type iborZeroVec(iborZeroVecSEXP );
        Rcpp::traits::input_parameter< std::string >::type iborType(iborTypeSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type evalDate(evalDateSEXP );
        Rcpp::List __result = calibrateHullWhiteUsingSwapsEngine(termStrcDateVec, termStrcZeroVec, swapDataDF, iborDateVec, iborZeroVec, iborType, evalDate);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// europeanOptionImpliedVolatilityEngine
double europeanOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volatility);
static SEXP RQuantLib_europeanOptionImpliedVolatilityEngine_try(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< double >::type value(valueSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volatility(volatilitySEXP );
        double __result = europeanOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volatility);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_europeanOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volatilitySEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_europeanOptionImpliedVolatilityEngine_try(typeSEXP, valueSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volatilitySEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// americanOptionImpliedVolatilityEngine
double americanOptionImpliedVolatilityEngine(std::string type, double value, double underlying, double strike, double dividendYield, double riskFreeRate, double maturity, double volguess, int timesteps, int gridpoints);
static SEXP RQuantLib_americanOptionImpliedVolatilityEngine_try(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volguessSEXP, SEXP timestepsSEXP, SEXP gridpointsSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< std::string >::type type(typeSEXP );
        Rcpp::traits::input_parameter< double >::type value(valueSEXP );
        Rcpp::traits::input_parameter< double >::type underlying(underlyingSEXP );
        Rcpp::traits::input_parameter< double >::type strike(strikeSEXP );
        Rcpp::traits::input_parameter< double >::type dividendYield(dividendYieldSEXP );
        Rcpp::traits::input_parameter< double >::type riskFreeRate(riskFreeRateSEXP );
        Rcpp::traits::input_parameter< double >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< double >::type volguess(volguessSEXP );
        Rcpp::traits::input_parameter< int >::type timesteps(timestepsSEXP );
        Rcpp::traits::input_parameter< int >::type gridpoints(gridpointsSEXP );
        double __result = americanOptionImpliedVolatilityEngine(type, value, underlying, strike, dividendYield, riskFreeRate, maturity, volguess, timesteps, gridpoints);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP RQuantLib_americanOptionImpliedVolatilityEngine(SEXP typeSEXP, SEXP valueSEXP, SEXP underlyingSEXP, SEXP strikeSEXP, SEXP dividendYieldSEXP, SEXP riskFreeRateSEXP, SEXP maturitySEXP, SEXP volguessSEXP, SEXP timestepsSEXP, SEXP gridpointsSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(RQuantLib_americanOptionImpliedVolatilityEngine_try(typeSEXP, valueSEXP, underlyingSEXP, strikeSEXP, dividendYieldSEXP, riskFreeRateSEXP, maturitySEXP, volguessSEXP, timestepsSEXP, gridpointsSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// zeroprice
double zeroprice(double yield, QuantLib::Date maturity, QuantLib::Date settle, int period, int basis);
RcppExport SEXP RQuantLib_zeroprice(SEXP yieldSEXP, SEXP maturitySEXP, SEXP settleSEXP, SEXP periodSEXP, SEXP basisSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< double >::type yield(yieldSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type settle(settleSEXP );
        Rcpp::traits::input_parameter< int >::type period(periodSEXP );
        Rcpp::traits::input_parameter< int >::type basis(basisSEXP );
        double __result = zeroprice(yield, maturity, settle, period, basis);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// zeroyield
double zeroyield(double price, QuantLib::Date maturity, QuantLib::Date settle, int period, int basis);
RcppExport SEXP RQuantLib_zeroyield(SEXP priceSEXP, SEXP maturitySEXP, SEXP settleSEXP, SEXP periodSEXP, SEXP basisSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< double >::type price(priceSEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type maturity(maturitySEXP );
        Rcpp::traits::input_parameter< QuantLib::Date >::type settle(settleSEXP );
        Rcpp::traits::input_parameter< int >::type period(periodSEXP );
        Rcpp::traits::input_parameter< int >::type basis(basisSEXP );
        double __result = zeroyield(price, maturity, settle, period, basis);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}

// validate (ensure exported C++ functions exist before calling them)
static int RQuantLib_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("QuantLib::Date(*advanceDate)(QuantLib::Date,int)");
        signatures.insert("std::vector<double>(*dayCount)(std::vector<QuantLib::Date>,std::vector<QuantLib::Date>,std::vector<double>)");
        signatures.insert("std::vector<double>(*yearFraction)(std::vector<QuantLib::Date>,std::vector<QuantLib::Date>,std::vector<double>)");
        signatures.insert("bool(*setEvaluationDate)(QuantLib::Date)");
        signatures.insert("double(*europeanOptionImpliedVolatilityEngine)(std::string,double,double,double,double,double,double,double)");
        signatures.insert("double(*americanOptionImpliedVolatilityEngine)(std::string,double,double,double,double,double,double,double,int,int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP RQuantLib_RcppExport_registerCCallable() { 
    R_RegisterCCallable("RQuantLib", "RQuantLib_advanceDate", (DL_FUNC)RQuantLib_advanceDate_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_dayCount", (DL_FUNC)RQuantLib_dayCount_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_yearFraction", (DL_FUNC)RQuantLib_yearFraction_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_setEvaluationDate", (DL_FUNC)RQuantLib_setEvaluationDate_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_europeanOptionImpliedVolatilityEngine", (DL_FUNC)RQuantLib_europeanOptionImpliedVolatilityEngine_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_americanOptionImpliedVolatilityEngine", (DL_FUNC)RQuantLib_americanOptionImpliedVolatilityEngine_try);
    R_RegisterCCallable("RQuantLib", "RQuantLib_RcppExport_validate", (DL_FUNC)RQuantLib_RcppExport_validate);
    return R_NilValue;
}
